[{"authors":["admin"],"categories":null,"content":"Between 2021 and 2024 I was an independent researcher at Karlsruher Institute für Technologie associated to the Topology group led by Roman Sauer.\nI was an assistant professor at the Adam Mickiewicz University from 2014 until 2021.\nThe Mathematical Institute of the Polish Academy of Sciences hosted me as visiting professor between 2015 and 2017, where I worked with Piotr Nowak on Kazhdan\u0026rsquo;s property (T).\nBetween 2019 and 2021 I was a postdoc in the MATH+ programm hosted at Technische Universität Berlin in the group of Michael Joswig, where I was working on machine learning aspects of polytope theory.\nMy research interests also include: geometric group theory (therefore: group actions), optimisation as well as symbolic and certified computation. Before, I used to work on topology of high-dimensional manifolds (surgery and equivariant surgery theory) and applied topology (persistence and others). An important part of my research has become programming \u0026ndash; the effects may be found on github.\nProgramming languages: Julia, Python\nSport: Climbing, Yoga\n","date":1605657600,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1605657600,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://kalmarek.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"Between 2021 and 2024 I was an independent researcher at Karlsruher Institute für Technologie associated to the Topology group led by Roman Sauer.\nI was an assistant professor at the Adam Mickiewicz University from 2014 until 2021.\nThe Mathematical Institute of the Polish Academy of Sciences hosted me as visiting professor between 2015 and 2017, where I worked with Piotr Nowak on Kazhdan\u0026rsquo;s property (T).\nBetween 2019 and 2021 I was a postdoc in the MATH+ programm hosted at Technische Universität Berlin in the group of Michael Joswig, where I was working on machine learning aspects of polytope theory.","tags":null,"title":"Marek Kaluba","type":"authors"},{"authors":["[Pierre-Emmanuel Caprace](https://perso.uclouvain.be/pierre-emmanuel.caprace/)","[Marston Conder](https://www.math.auckland.ac.nz/~conder/)","Marek Kaluba","[Stefan Witzel](https://www.math.uni-bielefeld.de/~switzel/)"],"categories":[],"content":"","date":1605657600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1605657600,"objectID":"6bda38b81c475ab0ee94827d22034732","permalink":"https://kalmarek.github.io/publication/2020-small-hyperbolic/","publishdate":"2020-11-18T00:00:00Z","relpermalink":"/publication/2020-small-hyperbolic/","section":"publication","summary":"We investigate generalized triangle groups in search for both hyperbolicity and property (T).","tags":[],"title":"Hyperbolic generalized triangle groups, property (T) and finite simple quotients","type":"publication"},{"authors":["[Michael Joswig](https://page.math.tu-berlin.de/~joswig/)","Marek Kaluba","[Lukas Ruff](https://www.ml.tu-berlin.de/menue/members/)"],"categories":[],"content":"","date":1601337600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1601337600,"objectID":"b39e7ba041285b62de75aaa0cab1e1da","permalink":"https://kalmarek.github.io/publication/2020-random-polytopes/","publishdate":"2020-09-29T00:00:00Z","relpermalink":"/publication/2020-random-polytopes/","section":"publication","summary":"We propose a new geometric method for measuring the quality of representations obtained from deep learning. Our approach, called _Random Polytope Descriptor_, provides an efficient description of data points based on the construction of random convex polytopes. We demonstrate the use of our technique by qualitatively comparing the behavior of classic and regularized autoencoders. This reveals that applying regularization to autoencoder networks may decrease the out-of-distribution detection performance in latent space. While our technique is similar in spirit to _k_-means clustering, we achieve significantly better false positive/negative balance in clustering tasks on autoencoded datasets.","tags":[],"title":"Geometric Disentanglement by Random Convex Polytopes","type":"publication"},{"authors":["Marek Kaluba","[Benjamin Lorenz](https://www.math.tu-berlin.de/?140078)","[Sascha Timme](https://sascha.timme.xyz)"],"categories":[],"content":"","date":1584921600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1584921600,"objectID":"f55f30741609fa443d51c4c8356151e5","permalink":"https://kalmarek.github.io/publication/2020-polymake_jl/","publishdate":"2020-03-23T00:00:00Z","relpermalink":"/publication/2020-polymake_jl/","section":"publication","summary":"A novel julia interface to **polymake**.","tags":[],"title":"Polymake.jl: A new interface to polymake","type":"publication"},{"authors":[],"categories":[],"content":" Splitting Conic Solver or scs is a well established solver for conic optimization problems. It has bindings to julia via SCS.jl.\nPart of each iteration of the solver is solving a system of linear equations. Scs provides some freedom in this respect. i.e. one can choose one of the following provided methods:\n Direct Solver using qdldl and amd Indirect Solver using conjugated gradient Indirect Solver on gpu using sparse conjugated gradient through CUDA  (You may also implement your own solver.)\nOn the julia side only the Direct and Indirect solvers are available (since #95). The main problem with providing the gpu solver is that cusparse works only with ints, so scs has to be compiled with DLONG=0 option, while other software (including julia) requires DLONG=1.\nIt means, that when user asks for the gpu solver we need not only cast our data appropriately, but also alternate the objects we\u0026rsquo;re passing to e.g. scs_solve, by changing the storage type, struct alignment etc. In julia we have a simple method for making this happen: parametrize the mirrored c-structs by the type of integer. Long story short: by checking out enh/gpu_solver branch you can enjoy the gpu solver even from julia.\nWell not quite, You need to compile scs first. We start with a tiny patch to scs.mk (a patch for using CUDA_PATH has been already merged, no need for it anymore).\nThen define env variables:\n CUDA_PATH pointing to cuda installation JULIA_LIBRARY_PATH pointing to ./lib/julia inside your julia installation  Finally compile scs with\nmake purge make -j4 CFLAGS=\u0026quot;-march=native\u0026quot; DLONG=1 USE_OPENMP=1 BLASLDFLAGS=\u0026quot;-L$JULIA_LIBRARY_PATH -lopenblas64_\u0026quot; BLAS64=1 BLASSUFFIX=_64_ LD_LIBRARY_PATH=$JULIA_LIBRARY_PATH ./out/demo_socp_direct 1000 0.5 0.5 1 LD_LIBRARY_PATH=$JULIA_LIBRARY_PATH ./out/demo_socp_indirect 1000 0.5 0.5 1 make clean # note DLONG=0 below! make -j4 CFLAGS=\u0026quot;-march=native\u0026quot; DLONG=0 USE_OPENMP=1 BLASLDFLAGS=\u0026quot;-L$JULIA_LIBRARY_PATH -lopenblas64_\u0026quot; BLAS64=1 BLASSUFFIX=_64_ gpu LD_LIBRARY_PATH=$JULIA_LIBRARY_PATH ./out/demo_socp_gpu 1000 0.5 0.5 1 make clean   We make purge at the beginning and make clean in the middle to get rid of partial products (as these were produced with DLONG=1). In addition we also run demos to make sure scs produced working libraries.   At this moment there should be three libraries in ./out: libscsdir, libscsindir and libscsgpuindir. (The first two are compiled with scs_int = long implied by DLONG=1, the last with scs_int = int. Assuming you\u0026rsquo;re on a sane platform.) Finally we need to set ENV[\u0026quot;JULIA_SCS_LIBRARY_PATH\u0026quot;]=/path/to/source/of/scs/out and issue Pkg.build(\u0026quot;SCS\u0026quot;) (don\u0026rsquo;t forget to dev SCS first).\nIf You want to be sure, check SCS.available_solvers and observe the output of Pkg.test(\u0026quot;SCS\u0026quot;)!\n","date":1562491714,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1562491714,"objectID":"7991cd7f0ad1eabfaafc1f2b7e1bd233","permalink":"https://kalmarek.github.io/post/scs-on-gpu-in-julia/","publishdate":"2019-07-07T11:28:34+02:00","relpermalink":"/post/scs-on-gpu-in-julia/","section":"post","summary":"Splitting Conic Solver or scs is a well established solver for conic optimization problems. It has bindings to julia via SCS.jl.\nPart of each iteration of the solver is solving a system of linear equations. Scs provides some freedom in this respect. i.e. one can choose one of the following provided methods:\n Direct Solver using qdldl and amd Indirect Solver using conjugated gradient Indirect Solver on gpu using sparse conjugated gradient through CUDA  (You may also implement your own solver.","tags":[],"title":"SCS on gpu in julia","type":"post"},{"authors":null,"categories":[],"content":"2021 2020  Polymake.jl: A new interface to polymake during ICMS 2020 Session: The Jupyter Environment for Computational Mathematics  2019   Buildings, Varieties, and Applications November 11 - 13, 2019, MPI für Mathematik in den Naturwissenschaften Leipzig September 2019, $\\operatorname{Aut}(F_n)$ has property (T), Outer Space in Bielefeld, Bielefeld, Germany (plenary talk) June 2019, $\\operatorname{Aut}(F_n)$ has property (T), Rigidity conference, Warsaw, Poland (plenary talk) February 2019, Computational aspects of property (T), seminar talk, RWTH, Aachen, Germany January 2019, Non-commutative positivity and Kazhdan\u0026rsquo;s property (T), seminar talk, University of Innsbruck, Innsbruck, Austria January 2019, Non-commutative positivity and Kazhdan\u0026rsquo;s property (T), seminar talk, Tokyo University of Science, Tokyo, Japan January 2019, On property (T) for $\\operatorname{Aut}(F_n)$ and $\\operatorname{SL}_n(\\mathbb{Z})$, seminar talk, University of Tokyo, Tokyo, Japan January 2019, On property (T) for $\\operatorname{Aut}(F_n)$ and $\\operatorname{SL}_n(\\mathbb{Z})$, seminar talk, University of Kagoshima, Kagoshima, Japan  2018  December 2018, $\\operatorname{Aut}(F_5)$ has property (T) at The 45th Symposium on Transformation Groups, Kumamoto, Japan December 2018, On property (T) for $\\operatorname{Aut}(F_n)$ and $\\operatorname{SL}_n(\\mathbb{Z})$, seminar talk, RIMS, Kyoto, Japan September 2018, Computational aspects of property (T) at Joint meeting of the Italian Mathematical Union, the Italian Society of Industrial and Applied Mathematics and the Polish Mathematical Society, Wrocław, Poland July 2018, Non-commutative positivity and property (T), seminar talk, TU Berlin, Berlin, Germany June 2018, Computational aspect of property (T), at International Conference on Manifolds, Groups and Homotopy, Isle of Skye, Scotland  2017  June 2017, Certifying numerical estimates of spectral gaps, at Applied Topology, Będlewo, Poland  2016  August 2016, Introduction to property (T), short course at Glances@Manifolds II, Kraków, Poland  ","date":1558088826,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1558088826,"objectID":"e3270a584294d8b4241ed23034fd8514","permalink":"https://kalmarek.github.io/blank/past-talks/","publishdate":"2019-05-17T12:27:06+02:00","relpermalink":"/blank/past-talks/","section":"blank","summary":"2021 2020  Polymake.jl: A new interface to polymake during ICMS 2020 Session: The Jupyter Environment for Computational Mathematics  2019   Buildings, Varieties, and Applications November 11 - 13, 2019, MPI für Mathematik in den Naturwissenschaften Leipzig September 2019, $\\operatorname{Aut}(F_n)$ has property (T), Outer Space in Bielefeld, Bielefeld, Germany (plenary talk) June 2019, $\\operatorname{Aut}(F_n)$ has property (T), Rigidity conference, Warsaw, Poland (plenary talk) February 2019, Computational aspects of property (T), seminar talk, RWTH, Aachen, Germany January 2019, Non-commutative positivity and Kazhdan\u0026rsquo;s property (T), seminar talk, University of Innsbruck, Innsbruck, Austria January 2019, Non-commutative positivity and Kazhdan\u0026rsquo;s property (T), seminar talk, Tokyo University of Science, Tokyo, Japan January 2019, On property (T) for $\\operatorname{Aut}(F_n)$ and $\\operatorname{SL}_n(\\mathbb{Z})$, seminar talk, University of Tokyo, Tokyo, Japan January 2019, On property (T) for $\\operatorname{Aut}(F_n)$ and $\\operatorname{SL}_n(\\mathbb{Z})$, seminar talk, University of Kagoshima, Kagoshima, Japan  2018  December 2018, $\\operatorname{Aut}(F_5)$ has property (T) at The 45th Symposium on Transformation Groups, Kumamoto, Japan December 2018, On property (T) for $\\operatorname{Aut}(F_n)$ and $\\operatorname{SL}_n(\\mathbb{Z})$, seminar talk, RIMS, Kyoto, Japan September 2018, Computational aspects of property (T) at Joint meeting of the Italian Mathematical Union, the Italian Society of Industrial and Applied Mathematics and the Polish Mathematical Society, Wrocław, Poland July 2018, Non-commutative positivity and property (T), seminar talk, TU Berlin, Berlin, Germany June 2018, Computational aspect of property (T), at International Conference on Manifolds, Groups and Homotopy, Isle of Skye, Scotland  2017  June 2017, Certifying numerical estimates of spectral gaps, at Applied Topology, Będlewo, Poland  2016  August 2016, Introduction to property (T), short course at Glances@Manifolds II, Kraków, Poland  ","tags":[],"title":"Past talks since 2016","type":"blank"},{"authors":[],"categories":[],"content":" Below are replication details for computations with special linear groups as described in Section 5.1 of paper On property (T) for $\\operatorname{Aut}(F_n)$ and $\\operatorname{SL}_n$. The content of the accompanying jupyter notebook is reproduced below.\nFor exact details of computations for $36(\\operatorname{Adj}_5 + 2 \\operatorname{Op}_5) - 50\\Delta_5 \\in I\\operatorname{SAut}(F_5)$ see the document deposited with the dataset in zenodo data repository.\n  Table of Contents  Generating set Group Ring and Laplacians Orbit Decomposition Elements Adj and Op Optimization Problem  Solving the problem   Checking the solution  Checking in interval arithmetic     Installation The following instructions were prepared using julia-1.1.1.\n Before exploring the notebook you need to clone the main repository:\ngit clone https://github.com/kalmarek/1812.03456.git  This notebook should be located in 1812.03456/notebooks directory.\nIn the main directory (1812.03456) you should run the following code in julias REPL console to instantiate the environment for computations:\nusing Pkg Pkg.activate(\u0026quot;.\u0026quot;) Pkg.instantiate()  (this needs to be done once per installation).\nInstantiation should install (among others): the SCS solver, JuMP package for mathematical programming and IntervalArithmetic.jl package from ValidatedNumerics.jl.\nThe environment uses Groups.jl, GroupRings.jl (which are built on the framework of AbstractAlgebra.jl) and PropertyT.jl packages.\nThe computation The following programme certifies that $$\\operatorname{Adj}_4 + \\operatorname{Op}_4 - 0.82\\Delta_4 =\\Sigma_i \\xi_i^*\\xi_i \\in \\Sigma^2_2\\mathbb{R}\\operatorname{SL}(4,\\mathbb{Z}).$$\nWith small changes (which we will indicate) it also certifies that $$\\operatorname{Adj}_3 - 0.157999\\Delta_3 \\in \\Sigma^2_2\\mathbb{R}\\operatorname{SL}(3,\\mathbb{Z})$$ and that $$\\operatorname{Adj}_5 +1.5 \\mathrm{Op}_5 - 1.5\\Delta_5 \\in \\Sigma^2_2\\mathbb{R}\\operatorname{SL}(5,\\mathbb{Z}).$$\nusing Pkg Pkg.activate(\u0026quot;..\u0026quot;) using Dates now()  2019-07-05T22:42:41.473  using LinearAlgebra using AbstractAlgebra using Groups using GroupRings using PropertyT  So far we only made the needed packages available in the notebook. In the next cell we define G to be the set of all $4\\times 4$ matrices over $\\mathbb Z$. (For the second computation, set N=3 below; for the third, set N=5)\nN = 4 G = MatrixAlgebra(zz, N)  Matrix Algebra of degree 4 over Integers  Generating set Now we create the elementary matrices $E_{i,j}$. The set of all such matrices and their inverses is denoted by S.\nS = PropertyT.generating_set(G)  24-element Array{AbstractAlgebra.Generic.MatAlgElem{Int64},1}: [1 1 0 0] [0 1 0 0] [0 0 1 0] [0 0 0 1] [1 0 1 0] [0 1 0 0] [0 0 1 0] [0 0 0 1] [1 0 0 1] [0 1 0 0] [0 0 1 0] [0 0 0 1] [1 0 0 0] [1 1 0 0] [0 0 1 0] [0 0 0 1] [1 0 0 0] [0 1 1 0] [0 0 1 0] [0 0 0 1] [1 0 0 0] [0 1 0 1] [0 0 1 0] [0 0 0 1] [1 0 0 0] [0 1 0 0] [1 0 1 0] [0 0 0 1] [1 0 0 0] [0 1 0 0] [0 1 1 0] [0 0 0 1] [1 0 0 0] [0 1 0 0] [0 0 1 1] [0 0 0 1] [1 0 0 0] [0 1 0 0] [0 0 1 0] [1 0 0 1] [1 0 0 0] [0 1 0 0] [0 0 1 0] [0 1 0 1] [1 0 0 0] [0 1 0 0] [0 0 1 0] [0 0 1 1] [1 -1 0 0] [0 1 0 0] [0 0 1 0] [0 0 0 1] [1 0 -1 0] [0 1 0 0] [0 0 1 0] [0 0 0 1] [1 0 0 -1] [0 1 0 0] [0 0 1 0] [0 0 0 1] [1 0 0 0] [-1 1 0 0] [0 0 1 0] [0 0 0 1] [1 0 0 0] [0 1 -1 0] [0 0 1 0] [0 0 0 1] [1 0 0 0] [0 1 0 -1] [0 0 1 0] [0 0 0 1] [1 0 0 0] [0 1 0 0] [-1 0 1 0] [0 0 0 1] [1 0 0 0] [0 1 0 0] [0 -1 1 0] [0 0 0 1] [1 0 0 0] [0 1 0 0] [0 0 1 -1] [0 0 0 1] [1 0 0 0] [0 1 0 0] [0 0 1 0] [-1 0 0 1] [1 0 0 0] [0 1 0 0] [0 0 1 0] [0 -1 0 1] [1 0 0 0] [0 1 0 0] [0 0 1 0] [0 0 -1 1]  Group Ring and Laplacians Now we will generate the ball E_R of radius $R=4$ in $\\operatorname{SL}(N,\\mathbb{Z})$ and use this as a (partial) basis in a group ring (denoted by RG below). Such group ring also needs a multiplication table (pm, which is actually a division table) which is created as follows: when $x,y$ reside at positions i-th and j-th in E_R, then pm[i,j] = k, where k is the position of $x^{-1}y$ in E_R.\nhalfradius = 2 E_R, sizes = Groups.generate_balls(S, radius=2*halfradius); E_rdict = GroupRings.reverse_dict(E_R) pm = GroupRings.create_pm(E_R, E_rdict, sizes[halfradius]; twisted=true); RG = GroupRing(G, E_R, E_rdict, pm) @show sizes; Δ = length(S)*one(RG) - sum(RG(s) for s in S)  sizes = [25, 433, 6149, 75197] 24[1 0 0 0] [0 1 0 0] [0 0 1 0] [0 0 0 1] - 1[1 1 0 0] [0 1 0 0] [0 0 1 0] [0 0 0 1] - 1[1 0 1 0] [0 1 0 0] [0 0 1 0] [0 0 0 1] - 1[1 0 0 1] [0 1 0 0] [0 0 1 0] [0 0 0 1] - 1[1 0 0 0] [1 1 0 0] [0 0 1 0] [0 0 0 1] - 1[1 0 0 0] [0 1 1 0] [0 0 1 0] [0 0 0 1] - 1[1 0 0 0] [0 1 0 1] [0 0 1 0] [0 0 0 1] - 1[1 0 0 0] [0 1 0 0] [1 0 1 0] [0 0 0 1] - 1[1 0 0 0] [0 1 0 0] [0 1 1 0] [0 0 0 1] - 1[1 0 0 0] [0 1 0 0] [0 0 1 1] [0 0 0 1] - 1[1 0 0 0] [0 1 0 0] [0 0 1 0] [1 0 0 1] - 1[1 0 0 0] [0 1 0 0] [0 0 1 0] [0 1 0 1] - 1[1 0 0 0] [0 1 0 0] [0 0 1 0] [0 0 1 1] - 1[1 -1 0 0] [0 1 0 0] [0 0 1 0] [0 0 0 1] - 1[1 0 -1 0] [0 1 0 0] [0 0 1 0] [0 0 0 1] - 1[1 0 0 -1] [0 1 0 0] [0 0 1 0] [0 0 0 1] - 1[1 0 0 0] [-1 1 0 0] [0 0 1 0] [0 0 0 1] - 1[1 0 0 0] [0 1 -1 0] [0 0 1 0] [0 0 0 1] - 1[1 0 0 0] [0 1 0 -1] [0 0 1 0] [0 0 0 1] - 1[1 0 0 0] [0 1 0 0] [-1 0 1 0] [0 0 0 1] - 1[1 0 0 0] [0 1 0 0] [0 -1 1 0] [0 0 0 1] - 1[1 0 0 0] [0 1 0 0] [0 0 1 -1] [0 0 0 1] - 1[1 0 0 0] [0 1 0 0] [0 0 1 0] [-1 0 0 1] - 1[1 0 0 0] [0 1 0 0] [0 0 1 0] [0 -1 0 1] - 1[1 0 0 0] [0 1 0 0] [0 0 1 0] [0 0 -1 1]  Orbit Decomposition Now something happens: in the next cell we split the subspace of $\\mathbb{R} \\operatorname{SL}(N, \\mathbb{Z})$ supported on E_R into irreducible representations of the wreath product $\\mathbb Z / 2 \\mathbb Z \\wr \\operatorname{Sym}_N$. The action of wreath product on the elements of the matrix space is by conjugation, i.e. permutation of rows and columns. We also compute projections on the invariant subspaces to later speed up the optimisation step.\nod = PropertyT.OrbitData(RG, WreathProduct(PermGroup(2), PermGroup(N))) orbit_data = PropertyT.decimate(od);  ┌ Info: Decomposing basis of RG into orbits of │ autS = Wreath Product of Permutation group over 2 elements by Permutation group over 4 elements └ @ PropertyT /home/kalmar/.julia/packages/PropertyT/yHEMH/src/orbitdata.jl:15 0.381708 seconds (1.18 M allocations: 82.083 MiB, 6.45% gc time) ┌ Info: The action has 558 orbits └ @ PropertyT /home/kalmar/.julia/packages/PropertyT/yHEMH/src/orbitdata.jl:18 ┌ Info: Finding projections in the Group Ring of │ autS = Wreath Product of Permutation group over 2 elements by Permutation group over 4 elements └ @ PropertyT /home/kalmar/.julia/packages/PropertyT/yHEMH/src/orbitdata.jl:20 6.154452 seconds (9.74 M allocations: 487.622 MiB, 4.69% gc time) ┌ Info: Finding AutS-action matrix representation └ @ PropertyT /home/kalmar/.julia/packages/PropertyT/yHEMH/src/orbitdata.jl:23 0.294136 seconds (963.71 k allocations: 64.184 MiB, 6.98% gc time) 0.440521 seconds (717.96 k allocations: 49.094 MiB, 4.87% gc time) ┌ Info: Computing the projection matrices Uπs └ @ PropertyT /home/kalmar/.julia/packages/PropertyT/yHEMH/src/orbitdata.jl:27 1.778654 seconds (1.75 M allocations: 841.323 MiB, 5.12% gc time) ┌ Info: │ multiplicities = 3 13 19 12 10 0 0 0 9 11 13 15 0 0 0 1 1 1 2 1 │ dimensions = 1 3 3 2 1 4 8 4 6 6 6 6 4 8 4 1 3 3 2 1 └ @ PropertyT /home/kalmar/.julia/packages/PropertyT/yHEMH/src/orbitdata.jl:37 ┌ Info: Sparsifying (433, 3)-matrix... │ 0.7013086989992302 → 0.18475750577367206 ), (240 non-zeros) └ @ PropertyT /home/kalmar/.julia/packages/PropertyT/yHEMH/src/orbitdata.jl:114 ┌ Info: Sparsifying (433, 13)-matrix... │ 0.5821637946349263 → 0.3084029134837449 ), (1736 non-zeros) └ @ PropertyT /home/kalmar/.julia/packages/PropertyT/yHEMH/src/orbitdata.jl:114 ┌ Info: Sparsifying (433, 19)-matrix... │ 0.6031360155585268 → 0.4934970220007293 ), (4060 non-zeros) └ @ PropertyT /home/kalmar/.julia/packages/PropertyT/yHEMH/src/orbitdata.jl:114 ┌ Info: Sparsifying (433, 12)-matrix... │ 0.6123941493456505 → 0.2817551963048499 ), (1464 non-zeros) └ @ PropertyT /home/kalmar/.julia/packages/PropertyT/yHEMH/src/orbitdata.jl:114 ┌ Info: Sparsifying (433, 10)-matrix... │ 0.48221709006928404 → 0.1 ), (433 non-zeros) └ @ PropertyT /home/kalmar/.julia/packages/PropertyT/yHEMH/src/orbitdata.jl:114 ┌ Info: Sparsifying (433, 9)-matrix... │ 0.24044136515268155 → 0.03695150115473441 ), (144 non-zeros) └ @ PropertyT /home/kalmar/.julia/packages/PropertyT/yHEMH/src/orbitdata.jl:114 ┌ Info: Sparsifying (433, 11)-matrix... │ 0.19462523619567498 → 0.033592273777031285), (160 non-zeros) └ @ PropertyT /home/kalmar/.julia/packages/PropertyT/yHEMH/src/orbitdata.jl:114 ┌ Info: Sparsifying (433, 13)-matrix... │ 0.16237342334340024 → 0.02842423165748801 ), (160 non-zeros) └ @ PropertyT /home/kalmar/.julia/packages/PropertyT/yHEMH/src/orbitdata.jl:114 ┌ Info: Sparsifying (433, 15)-matrix... │ 0.16874518860662047 → 0.027097767513471902), (176 non-zeros) └ @ PropertyT /home/kalmar/.julia/packages/PropertyT/yHEMH/src/orbitdata.jl:114 ┌ Info: Sparsifying (433, 1)-matrix... │ 0.11085450346420324 → 0.11085450346420324 ), (48 non-zeros) └ @ PropertyT /home/kalmar/.julia/packages/PropertyT/yHEMH/src/orbitdata.jl:114 ┌ Info: Sparsifying (433, 1)-matrix... │ 0.07390300230946882 → 0.07390300230946882 ), (32 non-zeros) └ @ PropertyT /home/kalmar/.julia/packages/PropertyT/yHEMH/src/orbitdata.jl:114 ┌ Info: Sparsifying (433, 1)-matrix... │ 0.07390300230946882 → 0.07390300230946882 ), (32 non-zeros) └ @ PropertyT /home/kalmar/.julia/packages/PropertyT/yHEMH/src/orbitdata.jl:114 ┌ Info: Sparsifying (433, 2)-matrix... │ 0.11200923787528869 → 0.09237875288683603 ), (80 non-zeros) └ @ PropertyT /home/kalmar/.julia/packages/PropertyT/yHEMH/src/orbitdata.jl:114 ┌ Info: Sparsifying (433, 1)-matrix... │ 0.11085450346420324 → 0.11085450346420324 ), (48 non-zeros) └ @ PropertyT /home/kalmar/.julia/packages/PropertyT/yHEMH/src/orbitdata.jl:114  Elements Adj and Op Now we define the elements $\\operatorname{Adj}_N$ and $\\operatorname{Op}_N$. The functions Sq, Adj, Op returning the appropriate elements are defined in the src/sqadjop.jl source file.\n@time AdjN = PropertyT.Adj(RG, N) @time OpN = PropertyT.Op(RG, N);   1.719218 seconds (2.70 M allocations: 134.807 MiB, 3.24% gc time) 0.284995 seconds (367.56 k allocations: 18.374 MiB, 2.55% gc time)  Finally we compute the element elt of our interest:\n if N=3: $\\operatorname{elt} = \\operatorname{Adj}_3$, if N=4: $\\operatorname{elt} = \\operatorname{Adj}_4 + \\operatorname{Op}_4$, if N=5: $\\operatorname{elt} = \\operatorname{Adj}_5 + 1.5\\operatorname{Op}_5$.  if N == 3 k = 0 elseif N == 4 k = 1 elseif N == 5 k = 1.5 end elt = AdjN + k*OpN; elt.coeffs   75197-element SparseArrays.SparseVector{Int64,Int64} with 361 stored entries: [1 ] = 480 [2 ] = -40 [3 ] = -40 [4 ] = -40 [5 ] = -40 [6 ] = -40 [7 ] = -40 [8 ] = -40 [9 ] = -40 [10 ] = -40 ⋮ [418 ] = 1 [420 ] = 1 [422 ] = 2 [423 ] = 1 [424 ] = 1 [425 ] = 1 [426 ] = 1 [428 ] = 1 [429 ] = 1 [430 ] = 1 [431 ] = 1  Optimization Problem We are ready to define the optimisation problem. Function\n PropertyT.SOS_problem(x, Δ, orbit_data; upper_bound=UB)\n defines the optimisation problem equivalent to the one of the form $$\\begin{aligned} \\text{ maximize : } \\quad \u0026amp; \\lambda\\ \\text{under constraints : }\\quad \u0026amp; 0 \\leqslant \\lambda \\leqslant \\operatorname{UB},\\ \u0026amp; x - \\lambda \\Delta = \\sum \\xi_i^* \\xi_i,\\ \\end{aligned}$$\n# @time SDP_problem, varλ, varP = PropertyT.SOS_problem(elt, Δ, orbit_data) if N == 3 UB = 0.158 elseif N == 4 UB = 0.82005 elseif N == 5 UB = 1.5005 end SDP_problem, varP = PropertyT.SOS_problem(elt, Δ, orbit_data; upper_bound=UB)  ┌ Info: Adding 558 constraints... └ @ PropertyT /home/kalmar/.julia/packages/PropertyT/yHEMH/src/sos_sdps.jl:92 1.916622 seconds (3.18 M allocations: 408.777 MiB, 12.54% gc time) (A JuMP Model Maximization problem with: Variables: 1388 Objective function type: JuMP.VariableRef `JuMP.VariableRef`-in-`MathOptInterface.LessThan{Float64}`: 1 constraint `JuMP.GenericAffExpr{Float64,JuMP.VariableRef}`-in-`MathOptInterface.EqualTo{Float64}`: 558 constraints `Array{JuMP.VariableRef,1}`-in-`MathOptInterface.PositiveSemidefiniteConeSquare`: 14 constraints Model mode: AUTOMATIC CachingOptimizer state: NO_OPTIMIZER Solver name: No optimizer attached. Names registered in the model: λ, Array{JuMP.VariableRef,2}[[noname noname noname; noname noname noname; noname noname noname], [noname noname … noname noname; noname noname … noname noname; … ; noname noname … noname noname; noname noname … noname noname], [noname noname … noname noname; noname noname … noname noname; … ; noname noname … noname noname; noname noname … noname noname], [noname noname … noname noname; noname noname … noname noname; … ; noname noname … noname noname; noname noname … noname noname], [noname noname … noname noname; noname noname … noname noname; … ; noname noname … noname noname; noname noname … noname noname], [noname noname … noname noname; noname noname … noname noname; … ; noname noname … noname noname; noname noname … noname noname], [noname noname … noname noname; noname noname … noname noname; … ; noname noname … noname noname; noname noname … noname noname], [noname noname … noname noname; noname noname … noname noname; … ; noname noname … noname noname; noname noname … noname noname], [noname noname … noname noname; noname noname … noname noname; … ; noname noname … noname noname; noname noname … noname noname], [noname], [noname], [noname], [noname noname; noname noname], [noname]])  using JuMP using SCS λ = Ps = warm = nothing  Solving the problem Depending on the actual problem one may need to tweak the parameters given to the solver:\n eps sets the requested accuracy max_iters sets the number of iterations to run before solver gives up alpha is a parameter ($\\alpha \\in (0,2)$) which determines the rate of convergence at the cost of the accuracy acceleration_lookback: if you experience numerical instability in scs log should be changed to 1 (at the cost of rate of convergence).  The parameters below should be enough to obtain a decent solution for $\\operatorname{SL}(4, \\mathbb{Z}), \\operatorname{SL}(5, \\mathbb{Z})$.\nFor $\\operatorname{SL}(3, \\mathbb{Z})$ approximately 1_000_000 of iterations is required; in this case by changing UB to $0.15$ (above) a much faster convergence can be observed.\nwith_SCS = with_optimizer(SCS.Optimizer, linear_solver=SCS.Direct, eps=3e-13, max_iters=10000, alpha=1.5, acceleration_lookback=10, warm_start=true) status, warm = PropertyT.solve(SDP_problem, with_SCS, warm);  ---------------------------------------------------------------------------- SCS v2.0.2 - Splitting Conic Solver (c) Brendan O'Donoghue, Stanford University, 2012-2017 ---------------------------------------------------------------------------- Lin-sys: sparse-direct, nnz in A = 130382 eps = 3.00e-13, alpha = 1.50, max_iters = 10000, normalize = 1, scale = 1.00 acceleration_lookback = 10, rho_x = 1.00e-03 Variables n = 1388, constraints m = 1946 Cones:\tprimal zero / dual free vars: 1196 linear vars: 1 sd vars: 749, sd blks: 14 Setup time: 8.46e-02s SCS using variable warm-starting ---------------------------------------------------------------------------- Iter | pri res | dua res | rel gap | pri obj | dua obj | kap/tau | time (s) ---------------------------------------------------------------------------- 0| 1.02e+00 1.23e+00 9.75e-01 -3.44e+01 4.76e+00 0.00e+00 2.96e-03 100| 1.68e-04 1.10e-03 1.18e-03 -8.19e-01 -8.16e-01 2.95e-16 1.65e-01 200| 1.86e-04 4.32e-04 1.38e-04 -8.19e-01 -8.20e-01 5.89e-16 3.40e-01 300| 6.04e-05 5.47e-04 1.30e-04 -8.19e-01 -8.19e-01 2.39e-17 5.22e-01 400| 1.35e-04 4.46e-04 2.68e-04 -8.19e-01 -8.20e-01 2.06e-15 6.93e-01 500| 1.35e-04 4.21e-04 3.66e-04 -8.19e-01 -8.20e-01 2.36e-15 8.59e-01 600| 4.90e-05 2.34e-04 2.32e-04 -8.20e-01 -8.19e-01 3.42e-16 1.02e+00 700| 2.12e-05 1.74e-04 1.49e-04 -8.20e-01 -8.19e-01 1.51e-15 1.19e+00 800| 6.12e-05 2.23e-04 2.15e-04 -8.20e-01 -8.19e-01 4.95e-16 1.37e+00 900| 3.99e-05 1.79e-04 3.29e-05 -8.20e-01 -8.20e-01 5.59e-16 1.54e+00 1000| 1.30e-05 1.93e-04 1.04e-04 -8.20e-01 -8.20e-01 1.37e-15 1.72e+00 1100| 2.31e-05 2.01e-04 9.26e-05 -8.20e-01 -8.19e-01 2.58e-16 1.89e+00 1200| 2.15e-05 1.68e-04 2.12e-04 -8.20e-01 -8.19e-01 1.20e-15 2.07e+00 1300| 2.32e-05 1.61e-04 1.64e-04 -8.20e-01 -8.19e-01 5.90e-17 2.24e+00 1400| 1.19e-05 1.13e-04 1.75e-04 -8.20e-01 -8.19e-01 5.17e-16 2.42e+00 1500| 8.01e-06 1.33e-04 8.49e-05 -8.20e-01 -8.20e-01 3.33e-16 2.59e+00 1600| 3.49e-05 1.50e-04 1.04e-04 -8.20e-01 -8.19e-01 3.73e-16 2.76e+00 1700| 2.28e-05 8.89e-05 5.56e-05 -8.20e-01 -8.20e-01 2.86e-16 2.92e+00 1800| 1.54e-05 9.31e-05 1.06e-04 -8.20e-01 -8.20e-01 4.60e-16 3.09e+00 1900| 9.36e-06 1.25e-04 4.95e-06 -8.20e-01 -8.20e-01 3.36e-15 3.26e+00 2000| 3.71e-05 8.99e-05 2.00e-05 -8.20e-01 -8.20e-01 3.53e-16 3.46e+00 2100| 7.38e-06 7.97e-05 5.16e-05 -8.20e-01 -8.20e-01 1.92e-15 3.64e+00 2200| 1.08e-05 7.21e-05 3.00e-05 -8.20e-01 -8.20e-01 8.14e-16 3.81e+00 2300| 6.20e-06 9.69e-05 5.00e-05 -8.20e-01 -8.20e-01 1.36e-15 3.98e+00 2400| 8.47e-06 8.09e-05 6.05e-05 -8.20e-01 -8.20e-01 2.48e-15 4.15e+00 2500| 2.39e-05 8.09e-05 3.22e-05 -8.20e-01 -8.20e-01 3.40e-15 4.33e+00 2600| 1.56e-05 5.56e-05 1.86e-05 -8.20e-01 -8.20e-01 1.13e-16 4.50e+00 2700| 6.45e-06 6.44e-05 7.46e-07 -8.20e-01 -8.20e-01 1.15e-16 4.67e+00 2800| 2.76e-06 4.58e-05 5.44e-05 -8.20e-01 -8.20e-01 3.67e-15 4.84e+00 2900| 3.68e-06 5.38e-05 3.21e-05 -8.20e-01 -8.20e-01 1.04e-15 5.02e+00 3000| 6.13e-06 5.96e-05 5.55e-05 -8.20e-01 -8.20e-01 2.67e-16 5.19e+00 3100| 1.15e-05 4.97e-05 2.32e-06 -8.20e-01 -8.20e-01 4.40e-16 5.37e+00 3200| 1.28e-05 3.79e-05 4.61e-05 -8.20e-01 -8.20e-01 2.80e-15 5.54e+00 3300| 1.01e-05 8.71e-05 3.11e-05 -8.20e-01 -8.20e-01 1.90e-15 5.73e+00 3400| 5.20e-06 4.60e-05 1.14e-05 -8.20e-01 -8.20e-01 1.77e-16 5.90e+00 3500| 2.60e-06 2.80e-05 1.28e-05 -8.20e-01 -8.20e-01 7.29e-16 6.06e+00 3600| 6.14e-06 4.07e-05 1.17e-05 -8.20e-01 -8.20e-01 1.41e-15 6.23e+00 3700| 2.59e-06 2.02e-05 7.04e-06 -8.20e-01 -8.20e-01 7.81e-16 6.40e+00 3800| 5.14e-06 3.43e-05 2.91e-05 -8.20e-01 -8.20e-01 3.08e-16 6.59e+00 3900| 1.77e-06 2.43e-05 3.56e-07 -8.20e-01 -8.20e-01 1.42e-15 6.75e+00 4000| 6.59e-06 2.22e-05 1.03e-05 -8.20e-01 -8.20e-01 2.65e-16 6.92e+00 4100| 2.81e-06 2.11e-05 1.35e-05 -8.20e-01 -8.20e-01 1.65e-15 7.09e+00 4200| 1.90e-06 2.91e-05 2.26e-05 -8.20e-01 -8.20e-01 1.54e-15 7.26e+00 4300| 4.63e-06 3.09e-05 1.42e-06 -8.20e-01 -8.20e-01 1.15e-15 7.43e+00 4400| 2.02e-06 1.69e-05 7.11e-06 -8.20e-01 -8.20e-01 8.27e-16 7.61e+00 4500| 9.67e-06 2.00e-05 5.91e-06 -8.20e-01 -8.20e-01 5.69e-16 7.77e+00 4600| 8.40e-07 4.23e-06 3.47e-06 -8.20e-01 -8.20e-01 2.54e-15 7.93e+00 4700| 1.33e-06 9.78e-06 4.42e-08 -8.20e-01 -8.20e-01 8.54e-16 8.09e+00 4800| 8.40e-07 2.94e-06 4.89e-06 -8.20e-01 -8.20e-01 2.71e-15 8.25e+00 4900| 5.06e-07 1.84e-06 1.09e-06 -8.20e-01 -8.20e-01 2.43e-15 8.40e+00 5000| 1.26e-06 3.09e-06 4.54e-06 -8.20e-01 -8.20e-01 5.48e-17 8.55e+00 5100| 1.15e-07 2.30e-07 2.20e-07 -8.20e-01 -8.20e-01 4.83e-15 8.71e+00 5200| 2.57e-08 2.21e-07 2.86e-09 -8.20e-01 -8.20e-01 3.43e-15 8.85e+00 5300| 1.07e-04 2.94e-04 2.86e-04 -8.20e-01 -8.21e-01 4.81e-12 9.00e+00 5400| 8.39e-09 1.30e-07 8.58e-08 -8.20e-01 -8.20e-01 1.72e-15 9.14e+00 5500| 1.12e-08 1.68e-07 9.26e-09 -8.20e-01 -8.20e-01 2.03e-15 9.30e+00 5600| 2.88e-06 1.85e-05 1.04e-05 -8.20e-01 -8.20e-01 6.67e-15 9.45e+00 5700| 2.10e-05 2.21e-04 7.80e-05 -8.20e-01 -8.20e-01 8.08e-15 9.65e+00 5800| 4.36e-07 1.32e-06 8.45e-07 -8.20e-01 -8.20e-01 1.36e-15 9.80e+00 5900| 3.68e-06 3.39e-05 1.88e-06 -8.20e-01 -8.20e-01 1.39e-15 9.95e+00 6000| 2.28e-08 2.05e-07 9.89e-08 -8.20e-01 -8.20e-01 1.26e-15 1.01e+01 6100| 4.73e-08 7.77e-08 3.29e-08 -8.20e-01 -8.20e-01 1.86e-15 1.03e+01 6200| 5.33e-09 1.65e-08 1.07e-08 -8.20e-01 -8.20e-01 2.61e-16 1.04e+01 6300| 5.08e-08 3.23e-07 2.44e-07 -8.20e-01 -8.20e-01 1.71e-14 1.05e+01 6400| 5.01e-14 8.48e-13 4.12e-13 -8.20e-01 -8.20e-01 4.17e-16 1.07e+01 6402| 4.42e-14 1.73e-13 6.97e-14 -8.20e-01 -8.20e-01 7.23e-16 1.07e+01 ---------------------------------------------------------------------------- Status: Solved Timing: Solve time: 1.07e+01s Lin-sys: nnz in L factor: 288182, avg solve time: 1.00e-03s Cones: avg projection time: 4.08e-04s Acceleration: avg step time: 1.74e-04s ---------------------------------------------------------------------------- Error metrics: dist(s, K) = 8.4711e-10, dist(y, K*) = 2.4476e-09, s'y/|s||y| = -3.2607e-15 primal res: |Ax + s - b|_2 / (1 + |b|_2) = 4.4176e-14 dual res: |A'y + c|_2 / (1 + |c|_2) = 1.7338e-13 rel gap: |c'x + b'y| / (1 + |c'x| + |b'y|) = 6.9723e-14 ---------------------------------------------------------------------------- c'x = -0.8201, -b'y = -0.8201 ============================================================================  λ = value(SDP_problem[:λ]) Ps = [value.(P) for P in varP] @show(status, λ);  status = OPTIMAL::TerminationStatusCode = 1 λ = 0.8200500000003405  Checking the solution Now we reconstruct the solution to the original problem over $\\mathbb{R} \\operatorname{SL}(N,\\mathbb{Z})$, which essentially boils down to averaging the obtained solution over the orbits of wreath product action: $$Q=\\frac{1}{|\\Sigma|}\\sum_{\\sigma\\in\\Sigma}\\sum_{\\pi\\in \\widehat{\\Sigma}} \\dim{\\pi}\\cdot\\sigma\\left(U_{\\pi}^T \\sqrt{P_{\\pi}} U_{\\pi}\\right).$$\nQs = real.(sqrt.(Ps)); Q = PropertyT.reconstruct(Qs, orbit_data);  As explained in the paper the columns of the square-root of the solution matrix provide the coefficients for $\\xi_i$\u0026rsquo;s in basis E_R of the group ring. Below we compute the residual $$ b = \\left(x - \\lambda\\Delta\\right) - \\sum \\xi_i^*\\xi_i.$$ As we do it in floating-point arithmetic, the result can\u0026rsquo;t be taken seriously.\nfunction SOS_residual(x::GroupRingElem, Q::Matrix) RG = parent(x) @time sos = PropertyT.compute_SOS(RG, Q); return x - sos end  SOS_residual (generic function with 1 method)  residual = SOS_residual(elt - λ*Δ, Q) @show norm(residual, 1);  ┌ Warning: Scalar and coeffs are in different rings! Promoting result to Float64 └ @ GroupRings /home/kalmar/.julia/packages/GroupRings/UwACc/src/GroupRings.jl:303 ┌ Warning: Adding elements with different coefficient rings, Promoting result to Float64 └ @ GroupRings /home/kalmar/.julia/packages/GroupRings/UwACc/src/GroupRings.jl:341 0.017873 seconds (977 allocations: 2.065 MiB) norm(residual, 1) = 8.53743030863061e-9  Checking in interval arithmetic using IntervalArithmetic IntervalArithmetic.setrounding(Interval, :tight) IntervalArithmetic.setformat(sigfigs=12);  Here we resort to interval arithmetic to provide certified upper and lower bounds on the norm of the residual.\n We first change entries of Q to narrow intervals We project columns of Q so that $0$ is in the sum of coefficients of each column (i.e. $\\xi_i \\in I \\operatorname{SL}(N,\\mathbb{Z})$) We compute the sum of squares and the $\\ell_1$-norm of the residual in the interval arithmetic.  The returned check_columns_augmentation is a boolean flag to detect if the projection was successful, i.e. if we can guarantee that each column of Q_aug can be represented by an element from the augmentation ideal. (If it were not successful, one may project Q = PropertyT.augIdproj(Q) in the floating point arithmetic prior to the cell below).\nThe resulting norm of the residual is guaranteed to be contained in the resulting interval. E.g. if each entry of Q were changed into an honest rational number and all the computations were carried out in rational arithmetic, the rational $\\ell_1$-norm will be contained in the interval $\\ell_1$-norm.\nQ_aug, check_columns_augmentation = PropertyT.augIdproj(Interval, Q); @assert check_columns_augmentation elt_int = elt - @interval(λ)*Δ; residual_int = SOS_residual(elt_int, Q_aug) @show norm(residual_int, 1);  ┌ Warning: Scalar and coeffs are in different rings! Promoting result to Interval{Float64} └ @ GroupRings /home/kalmar/.julia/packages/GroupRings/UwACc/src/GroupRings.jl:303 ┌ Warning: Adding elements with different coefficient rings, Promoting result to Interval{Float64} └ @ GroupRings /home/kalmar/.julia/packages/GroupRings/UwACc/src/GroupRings.jl:341 3.296487 seconds (976 allocations: 4.070 MiB) norm(residual_int, 1) = [1.06387679475e-08, 1.09608901207e-08]  certified_λ = @interval(λ) - 2^2*norm(residual_int,1)  [0.820049956156, 0.820049957446]  So $\\operatorname{elt} - \\lambda_0 \\Delta \\in \\Sigma^2 I\\operatorname{SL}(N, \\mathbb{Z})$, where as $\\lambda_0$ we could take the left end of the above interval:\ncertified_λ.lo  0.8200499561567799  using Dates now()  2019-07-05T22:44:09.949  versioninfo()  Julia Version 1.1.1 Commit 55e36cc308 (2019-05-16 04:10 UTC) Platform Info: OS: Linux (x86_64-pc-linux-gnu) CPU: Intel(R) Core(TM) i5-6200U CPU @ 2.30GHz WORD_SIZE: 64 LIBM: libopenlibm LLVM: libLLVM-6.0.1 (ORCJIT, skylake) Environment: JULIA_NUM_THREADS = 2   ","date":1547683200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1547683200,"objectID":"6b9f762e09fff767493168f0747293d4","permalink":"https://kalmarek.github.io/post/1812.03456/","publishdate":"2019-01-17T00:00:00Z","relpermalink":"/post/1812.03456/","section":"post","summary":"Below are replication details for computations with special linear groups as described in Section 5.1 of paper On property (T) for $\\operatorname{Aut}(F_n)$ and $\\operatorname{SL}_n$. The content of the accompanying jupyter notebook is reproduced below.\nFor exact details of computations for $36(\\operatorname{Adj}_5 + 2 \\operatorname{Op}_5) - 50\\Delta_5 \\in I\\operatorname{SAut}(F_5)$ see the document deposited with the dataset in zenodo data repository.\n  Table of Contents  Generating set Group Ring and Laplacians Orbit Decomposition Elements Adj and Op Optimization Problem  Solving the problem   Checking the solution  Checking in interval arithmetic     Installation The following instructions were prepared using julia-1.","tags":[],"title":"Replication Details for 1812.03456","type":"post"},{"authors":["Marek Kaluba","[Dawid Kielak](https://www.math.uni-bielefeld.de/~dkielak/)","[Piotr W. Nowak](http://pnowak.impan.pl/index/Piotr_W_Nowak.html)"],"categories":null,"content":" Replication details for computations with special linear groups as described in Section 5.1 of the paper are reproduced in a separate document.\nFor exact details of computations e.g. for $\\operatorname{Adj}_5 + 3 \\operatorname{Op}_5) - 1.4\\Delta_5 \\in I\\operatorname{SAut}(F_5)$ see the document deposited with the dataset in zenodo data repository.\n  ","date":1544227200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1544227200,"objectID":"a697fce29344c9da61c4f03ca2fdc13b","permalink":"https://kalmarek.github.io/publication/2018-property-t-for-autfn/","publishdate":"2018-12-08T00:00:00Z","relpermalink":"/publication/2018-property-t-for-autfn/","section":"publication","summary":"We prove that $\\operatorname{Aut}(F_n)$ has Kazhdan's property (T) for every $n \\geqslant 6$. Together with the previous result of Kaluba, Nowak, and Ozawa, this gives the same statement for $n \\geqslant 5$. We also provide new, explicit lower bounds for the Kazhdan constants of $\\operatorname{SAut}(F_n)$ (with $n \\geqslant 6$) and of $\\operatorname{SL}_n(\\mathbb{Z})$ (with $n \\geqslant 3$) with respect to natural generating sets. In the latter case, these bounds improve upon previously known lower bounds whenever $n  6$.","tags":[],"title":"On property (T) for $\\operatorname{Aut}(F_n)$ and $\\operatorname{SL}_n(\\mathbb{Z})$","type":"publication"},{"authors":["Marek Kaluba","[Piotr W. Nowak](http://pnowak.impan.pl/index/Piotr_W_Nowak.html)","[Narutaka Ozawa](http://www.kurims.kyoto-u.ac.jp/~narutaka/)"],"categories":null,"content":"The description of replication details.\n","date":1513814400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1513814400,"objectID":"822d991e6319d53207b5a84234f6c14e","permalink":"https://kalmarek.github.io/publication/2017-autf5-has-t/","publishdate":"2017-12-21T00:00:00Z","relpermalink":"/publication/2017-autf5-has-t/","section":"publication","summary":"We prove that $\\operatorname{Aut}(\\mathbb{F}_5)$ has Kazhdan's property (T).","tags":[],"title":"$\\operatorname{Aut}(\\mathbb{F}_5)$ has property (T)","type":"publication"},{"authors":[],"categories":[],"content":"This post documents replication details for paper $\\operatorname{Aut}(\\mathbb{F}_5)$ has property (T) by M. Kaluba, P.W. Nowak and N. Ozawa.\n The current version of replication details is located in Nextjournal docker container. The following notes are exported from there.   Table of Contents  Getting julia project Running tests (optional) Getting the pre-computed data   Recomputing from scratch group ring structure Loading the solution Certification   Setting up the environment The code below is designed to run on julia 1.1.0.\nBefore running any computations we need to set-up the environment and download the pre-computed data.\nGetting julia project git clone https://git.wmi.amu.edu.pl/kalmar/1712.07167.git  using Pkg Pkg.activate(\u0026quot;1712.07167\u0026quot;) Pkg.instantiate()  Pkg.status()  Running tests (optional) Now everything seems to be installed, but let\u0026rsquo;s check that things run as they should:\nPkg.test(\u0026quot;PropertyT\u0026quot;)  Getting the pre-computed data We need to download and unpack the data from Zenodo\nwget -O oSAutF5_r2.tar.xz \u0026quot;https://zenodo.org/record/1913734/files/oSAutF5_r2.tar.xz?download=1\u0026quot; tar xvf oSAutF5_r2.tar.xz  The above commands need to be typically run only once.\nReplicating computations for 1712.07167 This section shows how one should be able to replicate the computations presented in $\\operatorname{Aut}(\\mathbb{F}_5)$  has property (T) by M. Kaluba, P.W. Nowak and N. Ozawa.\nTo speed-up certain computations you may wish to set the environmental variable JULIA_NUM_THREADS to the number of (the physical) cores of cpu.\nusing Pkg Pkg.activate(\u0026quot;1712.07167\u0026quot;) using Groups using GroupRings using PropertyT using SparseArrays using LinearAlgebra using IntervalArithmetic using JLD BLAS.set_num_threads(Threads.nthreads())  In the cell below we define the group ring of the special automorphism group of the free group (by reading the division table from pm.jld file) and construct the Laplacian $$ \\Delta_5 = |S_5| - \\sum_{s\\in S_5} s $$\nremembering that in the ordered basis of $\\mathbb{R}\\operatorname{SAut}(\\mathbb{F}_5)$ the identity comes first with generators following directly after. Note that the generating set $S = S_5$ of $\\operatorname{SAut}(\\mathbb{F}_5)$ consists of exactly $80$ transvections (due to technical issue with the transition from julia-0.6 to julia-1.0 we can not load the supplied oSAutF5_r2/delta.jld file directly).\nG = SAut(FreeGroup(5)) pm = load(\u0026quot;oSAutF5_r2/pm.jld\u0026quot;, \u0026quot;pm\u0026quot;) RG = GroupRing(G, pm) @show RG S_size = 80 Δ_coeff = SparseVector(maximum(pm), collect(1:(1+S_size)), [S_size; -ones(S_size)]) Δ = GroupRingElem(Δ_coeff, RG); Δ² = Δ^2;  Recomputing from scratch group ring structure The computations above could be re-done from scratch (i.e. without relying on the provided pm) by executing\nradius = 2 G = SAut(FreeGroup(5)) S = AbstractAlgebra.gens(G); @time E₄, sizes = Groups.generate_balls(S, Id, radius=2radius) # takes lots of time and space E₄_rdict = GroupRings.reverse_dict(E₄) @time pm = GroupRings.create_pm(E₄, E₄_rdict, sizes[radius]; twisted=true) # takes lots of time and space RG = GroupRing(G, E₄, E₄_rdict, pm) Δ = PropertyT.spLaplacian(RG, S) Δ² = Δ^2  Loading the solution Next we load the solution $(\\lambda_0, P_0)$:\nλ₀ = load(\u0026quot;oSAutF5_r2/1.3/lambda.jld\u0026quot;, \u0026quot;λ\u0026quot;)  As can be seen, we will be comparing the accuracy of $P_0​$ below against the numerical value of $\\lambda_0 = 1.3​$.\nP₀ = load(\u0026quot;oSAutF5_r2/1.3/SDPmatrix.jld\u0026quot;, \u0026quot;P\u0026quot;) @time Q = real(sqrt(P₀))  Certification Now we project the columns of $Q$ to the augmentation ideal, in interval arithmetic. The returned check_columns_augmentation is a boolean flag to detect if the projection was successful, i.e. if we can guarantee that each column of Q_aug can be represented by an element from the augmentation ideal. (If it were not successful, one may project Q = PropertyT.augIdproj(Q) in the floating point arithmetic prior to the cell below).\nQ_aug, check_columns_augmentation = PropertyT.augIdproj(Interval, Q); @show check_columns_augmentation if !check_columns_augmentation @warn \u0026quot;Columns of Q are not guaranteed to represent elements of the augmentation ideal!\u0026quot; end  Finally we compute the actual sum of squares decomposition represented by Q_aug:\n@time sos = PropertyT.compute_SOS(RG, Q_aug);  The residual of the solution and $\\Delta^2 - \\lambda_0\\Delta$ is\nresidual = Δ² - @interval(λ₀)*Δ - sos; norm(residual, 1) [8.35381e-06, 8.42859e-06]  thus we can certify that the spectral gap $\\lambda(\\operatorname{SAut}(\\mathbb{F}_5), S_5)$ is at least the lower end of the interval\ncertified = @interval(λ₀) - 2^2*norm(residual, 1) [1.29996, 1.29997]  which is exactly\nprint(certified.lo)  This, via estimate $\\kappa \\geqslant \\sqrt{\\frac{2\\lambda}{|S|}}$ leads to the lower bound on the Kazhdan constant of\nκ = (sqrt(2certified/S_size)).lo 0.180275  Deprecated Instructions for running with julia-0.6.  This section is left only for historic reasons of the specific code run in preparation of 1712.07167.   Clone https://git.wmi.amu.edu.pl/kalmar/GroupsWithPropertyT and checkout the 1712.07167 branch:\ngit clone https://git.wmi.amu.edu.pl/kalmar/GroupsWithPropertyT.git cd ./GroupsWithPropertyT git checkout 1712.07167  In julias REPL execute\nPkg.add(\u0026quot;ArgParse\u0026quot;) Pkg.add(\u0026quot;Nemo\u0026quot;) Pkg.clone(\u0026quot;https://git.wmi.amu.edu.pl/kalmar/Groups.jl.git\u0026quot;) Pkg.checkout(\u0026quot;Groups\u0026quot;, \u0026quot;1712.07167\u0026quot;) Pkg.clone(\u0026quot;https://git.wmi.amu.edu.pl/kalmar/GroupRings.jl.git\u0026quot;) Pkg.checkout(\u0026quot;GroupRings\u0026quot;, \u0026quot;1712.07167\u0026quot;) Pkg.clone(\u0026quot;https://git.wmi.amu.edu.pl/kalmar/PropertyT.jl.git\u0026quot;) Pkg.checkout(\u0026quot;PropertyT\u0026quot;, \u0026quot;1712.07167\u0026quot;) Pkg.checkout(\u0026quot;SCS\u0026quot;) Pkg.build(\u0026quot;SCS\u0026quot;)  This should resolve all the dependencies. Quit julia and place the oSAutF5_r2 folder downloaded from Zenodo research data repository inside GroupsWithPropertyT folder. To verify the decomposition of $\\Delta^2 - \\lambda \\Delta$ for the group run (if You have a 4-core CPU at Your disposal)\njulia AutFN_orbit.jl -N 5 --upper-bound=1.2 --cpus 4  If You want to generate the (twisted) multiplication table (and other required files) on Your own delete all *.jld files from the oSAutF5_r2 folder (except for 1.2 folder and its contents) and run the same command again.\n You need at least 32GB of RAM and spare 24h of Your CPU.   ","date":1513814400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1513814400,"objectID":"c136e2e10ca8b8922ea3267eb9612433","permalink":"https://kalmarek.github.io/post/1712.07176/","publishdate":"2017-12-21T00:00:00Z","relpermalink":"/post/1712.07176/","section":"post","summary":"This post documents replication details for paper $\\operatorname{Aut}(\\mathbb{F}_5)$ has property (T) by M. Kaluba, P.W. Nowak and N. Ozawa.\n The current version of replication details is located in Nextjournal docker container. The following notes are exported from there.   Table of Contents  Getting julia project Running tests (optional) Getting the pre-computed data   Recomputing from scratch group ring structure Loading the solution Certification   Setting up the environment The code below is designed to run on julia 1.","tags":[],"title":"Replication Details for 1712.07167","type":"post"},{"authors":["Marek Kaluba","[Piotr W. Nowak](http://pnowak.impan.pl/index/Piotr_W_Nowak.html)"],"categories":null,"content":"The description of replication details.\n","date":1490659200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1490659200,"objectID":"b74d48f53cb6fc7fb8e3b66e6788393a","permalink":"https://kalmarek.github.io/publication/2017-certifying-spectral-gaps/","publishdate":"2017-03-28T00:00:00Z","relpermalink":"/publication/2017-certifying-spectral-gaps/","section":"publication","summary":"We establish a lower bound on the spectral gap of the Laplace operator on some special linear groups using conic optimisation.","tags":[],"title":"Certifying Numerical Estimates of Spectral Gaps","type":"publication"},{"authors":[],"categories":[],"content":"This post documents replication details for paper Certifying numerical estimates of spectral gaps by M. Kaluba, P.W. Nowak.\n This guide is rather outdated. All of the computations can be done (and much more effectively) by exploiting the symmetry of the Laplacian as is described in Replication Details for 1712.07167. For more details on the method see $\\operatorname{Aut}(\\mathbb{F}_5)$ has property (T).   Table of Contents  Installing To run the code You need julia-v0.5 (should work on v0.6, but with warnings). You also need to install julia packages: Nemo-v0.6.3, ArgParse. To do so in julia\u0026rsquo;s REPL run:\nPkg.update() Pkg.add(\u0026quot;Nemo\u0026quot;) Pkg.add(\u0026quot;ArgParse\u0026quot;)  Then clone the main repository of Groups.jl, GroupRings.jl and PropertyT.jl:\nPkg.clone(\u0026quot;https://git.wmi.amu.edu.pl/kalmar/Groups.jl.git\u0026quot;) Pkg.clone(\u0026quot;https://git.wmi.amu.edu.pl/kalmar/GroupRings.jl.git\u0026quot;) Pkg.clone(\u0026quot;https://git.wmi.amu.edu.pl/kalmar/PropertyT.jl.git\u0026quot;) Pkg.resolve()  This should resolve all dependencies (e.g. install JuMP, SCS, IntervalArithmetic, JLD, Memento). Exit julia and clone GroupswithPropertyT\ngit clone https://git.wmi.amu.edu.pl/kalmar/GroupsWithPropertyT.git cd GroupswithPropertyT  Running To check that $\\Delta^2-\\lambda\\Delta$ is not decomposable to a sum of hermitian squares of elements in the ball of radius $2$ in $SL(2,7)$ run\njulia SL.jl -N 2 -p 7 --radius 2 --iterations 100000  (~30 seconds, depending on hardware). The monotonous decreasing $\\lambda$ during the optimisation is in column pri obj (or dua obj) of solver.log.\nCompare this to\njulia SL.jl -N 2 -p 7 --radius 3 --iterations 100000  which finds $\\lambda \\geq 0.5857$ and decomposes $\\Delta^2-\\lambda\\Delta$ into sum of $47$ hermitian squares in less than 20 seconds (including certification).\nIf You see in the output (or in full.log) that the upper end of the interval where $\\lVert\\Delta^2 - \\lambda\\Delta - \\sum{\\xi_i}^*\\xi_i\\rVert_1$ belongs to is too large (resulting in positive Floating point distance, but negative The Augmentation-projected actual distance), decrease the --tol parameter, e.g.\njulia SL.jl -N 2 -p 7 --radius 3 --iterations 100000 --tol 1e-9  to achieve a better estimate (the residuals $\\ell_1$-norm should be around $|B_d(e))|*tol$)\nHelp julia SL.jl --help usage: SL.jl [--tol TOL] [--iterations ITERATIONS] [--upper-bound UPPER-BOUND] [--cpus CPUS] [-N N] [-p P] [--radius RADIUS] [-h] optional arguments: --tol TOL set numerical tolerance for the SDP solver (type: Float64, default: 1.0e-6) --iterations ITERATIONS set maximal number of iterations for the SDP solver (default: 20000) (type: Int64, default: 50000) --upper-bound UPPER-BOUND Set an upper bound for the spectral gap (type: Float64, default: Inf) --cpus CPUS Set number of cpus used by solver (type: Int64) -N N Consider elementary matrices EL(N) (type: Int64, default: 2) -p P Matrices over field of p-elements (p=0 =\u0026gt; over ZZ) (type: Int64, default: 0) --radius RADIUS Radius of ball B_r(e,S) to find solution over (type: Int64, default: 2) -h, --help show this help message and exit  Specific version of the article To checkout the specific versions of packages used for Certifying Numerical Estimates of Spectral Gaps run (inside GroupswithPropertyT)\ngit checkout 1703.09680v1  You need to link ~/.julia/v0.5/GroupRings to ~/.julia/v0.5/GroupAlgebras due to change in the name of the package. Then run in julia\nPkg.checkout(\u0026quot;GroupRings\u0026quot;, \u0026quot;1703.09680v1\u0026quot;) Pkg.checkout(\u0026quot;PropertyT\u0026quot;, \u0026quot;1703.09680v1\u0026quot;) Pkg.resolve()  ","date":1490659200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1490659200,"objectID":"7519662bcc4dd5c8c154fee8d213765e","permalink":"https://kalmarek.github.io/post/1703.09680/","publishdate":"2017-03-28T00:00:00Z","relpermalink":"/post/1703.09680/","section":"post","summary":"This post documents replication details for paper Certifying numerical estimates of spectral gaps by M. Kaluba, P.W. Nowak.\n This guide is rather outdated. All of the computations can be done (and much more effectively) by exploiting the symmetry of the Laplacian as is described in Replication Details for 1712.07167. For more details on the method see $\\operatorname{Aut}(\\mathbb{F}_5)$ has property (T).   Table of Contents  Installing To run the code You need julia-v0.","tags":[],"title":"Replication details for 1703.09680","type":"post"},{"authors":["[Zbigniew Błaszczyk](https://blaszczyk.faculty.wmi.amu.edu.pl/)","Marek Kaluba"],"categories":[],"content":"","date":1458000000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1458000000,"objectID":"7a099343a39f76a679c797c80fe5d5ca","permalink":"https://kalmarek.github.io/publication/2016-exotic-actions/","publishdate":"2016-03-15T00:00:00Z","relpermalink":"/publication/2016-exotic-actions/","section":"publication","summary":"We construct non-product action on a product of asymmetric manifold and a low-dimensional sphere.","tags":[],"title":"Constructions of exotic actions on product manifolds with an asymmetric factor","type":"publication"},{"authors":["[Zbigniew Błaszczyk](https://blaszczyk.faculty.wmi.amu.edu.pl/)","Marek Kaluba"],"categories":null,"content":"","date":1446076800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1446076800,"objectID":"c45daa4e21b305163660376316044227","permalink":"https://kalmarek.github.io/publication/2015-effective-tc/","publishdate":"2015-10-29T00:00:00Z","relpermalink":"/publication/2015-effective-tc/","section":"publication","summary":"We try to integrate group actions to the topological complexity setting, by introducing «jumps» in the planner. This approach is based on the assumption that motion planning on a «fundamental domain», should contain all the information of a (reasonable) motion planning.","tags":[],"title":"Effective topological complexity of spaces with symmetries","type":"publication"},{"authors":["[Zbigniew Błaszczyk](https://blaszczyk.faculty.wmi.amu.edu.pl/)","Marek Kaluba"],"categories":null,"content":"","date":1422576000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1422576000,"objectID":"0565e432d6f5bea8078088373b96e4f9","permalink":"https://kalmarek.github.io/publication/2015-tc-of-zp-spheres/","publishdate":"2015-01-30T00:00:00Z","relpermalink":"/publication/2015-tc-of-zp-spheres/","section":"publication","summary":"We compute and compare the invariant and equivariant versions of TC for various spaces and ponder what is the right way to introduce group actions into the picture.","tags":[],"title":"On equivariant and invariant topological complexity of smooth $\\mathbb{Z}/p$-spheres","type":"publication"},{"authors":["Marek Kaluba","[Krzysztof Pawałowski](https://kpa.faculty.wmi.amu.edu.pl/)"],"categories":null,"content":"Let $G$ be a compact Lie group. For specific manifolds $M$, such as Euclidean spaces, disks, spheres, and complex projective spaces consider the following realisation problem.\n Which manifolds $F$ are diffeomorphic to the corresponding fixed points sets $M^G$ for some action of $G$ on $M$?  Our goal is to discuss results related to the first question obtained so far for actions on Euclidean spaces, disks, and spheres, and then to describe new results for actions on complex projective spaces obtained by the first author in his PhD Thesis. Hence, every manifold $F$ which occurs as the fixed point set is a second-countable space, i.e., $F$ is paracompact and $F$ has countably many connected components, possibly not of the same dimension.\n","date":1417219200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1417219200,"objectID":"48f6f0e7e5d54c9dac0cafc14f6da8d6","permalink":"https://kalmarek.github.io/publication/2014-rims-kyoto/","publishdate":"2014-11-29T00:00:00Z","relpermalink":"/publication/2014-rims-kyoto/","section":"publication","summary":"We survey the results on group actions on Euclidean spaces, disks and spheres and summarise my results on perfect group actions on complex projective spaces. This is based on the results of my PhD Thesis.","tags":[],"title":"Group actions on complex projective spaces","type":"publication"},{"authors":["Marek Kaluba","[Wacław Marzantowicz](http://www.staff.amu.edu.pl/~marzan/)","Nelson Silva"],"categories":null,"content":"","date":1400457600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1400457600,"objectID":"8724def12cd8047054636e7078d10714","permalink":"https://kalmarek.github.io/publication/2014-reeb-graph/","publishdate":"2014-05-19T00:00:00Z","relpermalink":"/publication/2014-reeb-graph/","section":"publication","summary":"We show how to draw (in a \"decreasing\" way) the Reeb graph $\\mathcal{R}(f)$ on manifold via gradient flow of $f$. We use this embedding to prove sharper bounds relating the structure of the fundamental group and the number of loops in $\\mathcal{R}(f)$.","tags":[],"title":"On Representation of the Reeb Graph as a Sub Complex of Manifold","type":"publication"},{"authors":["Marek Kaluba","[Wojciech Politarczyk](https://politarczyk.faculty.wmi.amu.edu.pl/)"],"categories":null,"content":"","date":1310428800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1310428800,"objectID":"3c227b6411881cb2abd6955bc2dc6ca3","permalink":"https://kalmarek.github.io/publication/2012-non-symplectic/","publishdate":"2011-07-12T00:00:00Z","relpermalink":"/publication/2012-non-symplectic/","section":"publication","summary":"We construct smooth actions of arbitrary compact Lie groups on $\\mathbb{C}P^n$ complex projective spaces, such that the corresponding transformations do not preserve any symplectic structure on $\\mathbb{C}P^n$.","tags":[],"title":"Non Symplectic Actions on Complex Projective Spaces","type":"publication"}]